import dismantlable

variables {V: Type} [fintype V] [inhabited V] [decidable_eq V] {c: V}

open classical
noncomputable theory

-- Induced subgraph generated by a vertex set S ⊆ V
def induced_subgraph (S: set V) (G: refl_graph V) : refl_graph {v:V// v ∈ S} :=
{ adj := λ a b, G.adj a b,
  sym :=  λ a b h, G.sym h,
  selfloop := begin intro a, apply G.selfloop end}

lemma ind_subgraph_is_induced {G: refl_graph V} : ∀ S: set V, ∀ v w : {v:V// v ∈ S}, G.adj v w ↔ (induced_subgraph S G).adj v w :=
begin
  intros S v w, split, 
  intro Gadj, rw induced_subgraph, exact Gadj,
  intro Iadj, rw induced_subgraph at Iadj, exact Iadj, 
end

-- Induced subgraph of one vertex removed
def ind_subgraph_one_vtx (v: V) (G: refl_graph V) : refl_graph {w : V // w ≠ v}
:= induced_subgraph (λ x, x ≠ v) G

-- v is the cornered vtx. cing_vtx is the vtx cornering v
def cing_vtx {v: V} {G: refl_graph V} (h: corner_vtx G v) :=
some h

-- a vertex can't corner itself
theorem cing_vtx_distinct {v: V} {G: refl_graph V} (h: corner_vtx G v) : cing_vtx h ≠ v :=
begin
  obtain ⟨hw1, hw2⟩ := (some_spec h),
  exact hw1
end

-- subset inclusion property of corners
theorem cing_vtx_nhds {v: V} {G: refl_graph V} (h: corner_vtx G v) : neighbor_set' G v ⊆ neighbor_set' G (cing_vtx h) :=
begin
  obtain ⟨hw1, hw2⟩ := (some_spec h),
  exact hw2
end

lemma cing_vtx_nhds_vtx {v: V} {G: refl_graph V} (h: corner_vtx G v) : ∀ w: V, G.adj v w → G.adj (cing_vtx h) w :=
begin
  obtain ⟨hw1, hw2⟩ := (some_spec h),
  intros w hw, conv at hw2 {congr, rw neighbor_set', skip, rw neighbor_set'}, 
  exact set.mem_of_subset_of_mem hw2 hw,
end

-- from type V to subtype {w: V // w ≠ v}, for cornering vtxs
def cing_vtx_subtype {v: V} {G: refl_graph V} (h: corner_vtx G v) : {w: V // w ≠ v}
:= ⟨cing_vtx h, cing_vtx_distinct h⟩

-- correctness of cing_vtx_subtype
theorem val_cing_vtx_subtype {v: V} {G: refl_graph V} (h: corner_vtx G v) : (cing_vtx_subtype h).val = cing_vtx h := rfl

-- from type V to subtype {w: V // w ≠ v}, for cornering vtxs
def not_corner_vtx_subtype (v: V) (G: refl_graph V) (h: v ≠ c) : {w: V // w ≠ c} := ⟨v,h⟩

def has_retract  (G: refl_graph V)  : Prop := 
∃ f: graph_hom G (ind_subgraph_one_vtx c G), ∀ v ≠ c, v = f.to_fun(v)

def retract_fun (G: refl_graph V) (h : corner_vtx G c) :
V → {w: V // w ≠ c} := λ v, if eq: v = c then cing_vtx_subtype h else ⟨v,eq⟩

--retract_fun works correctly
lemma retract_fun_works_pos_refl (G: refl_graph V) (h: corner_vtx G c) :
let H:= ind_subgraph_one_vtx c G in
H.adj (retract_fun G h c) (cing_vtx_subtype h) :=
begin
  intro H,
  suffices : retract_fun G h c = cing_vtx_subtype h,
  rw this, exact H.selfloop (cing_vtx_subtype h),
  rw retract_fun, simp,
end

lemma retract_fun_works_neg_refl (G: refl_graph V) (H:= ind_subgraph_one_vtx c G) (h: corner_vtx G c) :
∀ (v: V) (ne: v ≠ c), H.adj (retract_fun G h v) (not_corner_vtx_subtype v G ne) :=
begin
  intros v ne,
  suffices : retract_fun G h v = not_corner_vtx_subtype v G ne,
  rw this, exact H.selfloop (not_corner_vtx_subtype v G ne),
  rw retract_fun, simp, rw [dif_neg ne, not_corner_vtx_subtype],
end

-- retract_fun preserves edge relations
lemma retract_fun_works_pos_adj (G: refl_graph V) (h: corner_vtx G c) :
∀ (v: V) (adj: G.adj c v), (ind_subgraph_one_vtx c G).adj (retract_fun G  h c) (retract_fun G  h v) :=
begin
  intros v hyp, by_cases eq: v=c, rw eq, exact (ind_subgraph_one_vtx c G).selfloop (retract_fun G h c),
  rw retract_fun, simp, rw [dif_neg eq], rw cing_vtx_subtype,
  have adj : G.adj (cing_vtx h) v,
    exact cing_vtx_nhds_vtx h v hyp,
  rw ind_subgraph_one_vtx, 
  exact (ind_subgraph_is_induced (λ (x : V), x ≠ c) ⟨cing_vtx h, _⟩ ⟨v, eq⟩).1 adj,
end

-- retract function is identity on non-corner vtxs
def retract_fn_noncorner_vtx (G: refl_graph V) (h: corner_vtx G c) : ∀ (v: {w // w ≠ c}), retract_fun G h ↑v = v :=
begin
  intro v, rw [retract_fun], simp, rw cing_vtx_subtype, intro eq,
  have neq : ↑ v ≠ c, exact v.2, exfalso, exact neq eq,
end

def retract_fn_noncorner_vtx_fn (G: refl_graph V) (h: corner_vtx G c) : function.equiv ((retract_fun G h) ∘ coe) (λ x, x) :=
begin
  rw function.equiv, exact retract_fn_noncorner_vtx G h,
end

--retract function is identity on lists and vectors as well
def retract_fn_noncorner_vtx_list (G: refl_graph V) (h: corner_vtx G c) : ∀ (v: list {w // w ≠ c}), list.map (retract_fun G h ∘ coe) v = v :=
begin
  intro v, induction v, simp,
  simp, split, exact retract_fn_noncorner_vtx G h v_hd, exact v_ih,
end

def retract_fn_noncorner_vtx_vect {n : ℕ } (G: refl_graph V) (h: corner_vtx G c) : ∀ (v: vector  {w // w ≠ c} n), vector.map (retract_fun G h ∘ coe) v = v :=
begin
  intro v, induction v, rw vector.map, simp, exact retract_fn_noncorner_vtx_list G h v_val,
end

def vec_map_comp {a b c: Type} {n : ℕ} (f: a → b) (g: b → c) : ∀ (v: vector a n), vector.map g (vector.map f v) = vector.map (g ∘ f) v :=
begin
  intro v, induction v, rw vector.map, rw vector.map, rw vector.map, simp,
end

lemma ind_subgraph_is_induced' {G: refl_graph V} (h: corner_vtx G c): ∀ v w : V, G.adj v w → (ind_subgraph_one_vtx c G).adj ((retract_fun G h) v) ((retract_fun G h) w) :=
begin
  intros v w,
  rw retract_fun, simp, 
  by_cases v_eq : v=c, by_cases w_eq : w=c,
  rw [dif_pos v_eq, dif_pos w_eq, v_eq, w_eq], intro Gadj,
  exact (ind_subgraph_one_vtx c G).selfloop (cing_vtx_subtype h),
  rw [dif_pos v_eq, dif_neg w_eq, cing_vtx_subtype], intro Gadj, rw v_eq at Gadj,
  let nbors := cing_vtx_nhds_vtx h w Gadj,
  exact (ind_subgraph_is_induced (λ x, x ≠ c) ⟨cing_vtx h, _⟩ ⟨w, w_eq⟩).1 nbors,
  by_cases w_eq : w=c,
  rw [dif_neg v_eq, dif_pos w_eq, cing_vtx_subtype], intro Gadj, rw [w_eq, rgraph_adj_symm] at Gadj,
  let nbors := cing_vtx_nhds_vtx h v Gadj,
  let ind := (ind_subgraph_is_induced (λ x, x ≠ c) ⟨cing_vtx h, _⟩ ⟨v, v_eq⟩).1 nbors,
  exact rgraph_adj_symm.1 ind,
  rw [dif_neg v_eq, dif_neg w_eq],
  exact (ind_subgraph_is_induced (λ x, x ≠ c) ⟨v, v_eq⟩ ⟨w, w_eq⟩).1,
end

def corner_retract (G: refl_graph V) (h : corner_vtx G c): graph_hom G (ind_subgraph_one_vtx c G) :=
{ to_fun := retract_fun G h,
  map_edges :=
  begin
    let H := (ind_subgraph_one_vtx c G),
    intros v w adj, by_cases v_eq: v=c, by_cases w_eq: w = c,
    rw [v_eq, w_eq], exact H.selfloop (retract_fun G h c),
    rw v_eq, rw v_eq at adj, exact retract_fun_works_pos_adj G h w adj,
    by_cases w_eq: w=c,
    rw retract_fun, simp, rw [dif_neg v_eq, dif_pos w_eq, cing_vtx_subtype], 
    rw [w_eq, rgraph_adj_symm] at adj,
    let cing_vtx_adj := cing_vtx_nhds_vtx h v adj,
    exact (ind_subgraph_is_induced (λ (x : V), x ≠ c) ⟨v, v_eq⟩ ⟨cing_vtx h, _⟩).1(rgraph_adj_symm.1 cing_vtx_adj),
    rw retract_fun, simp, rw [dif_neg v_eq, dif_neg w_eq],
    exact (ind_subgraph_is_induced (λ (x : V), x ≠ c) ⟨v, v_eq⟩ ⟨w, w_eq⟩).1 adj,
  end
}

def image_strat_init {n: ℕ} (G: refl_graph V) (h: corner_vtx G c) (CS: cop_strat G n) : vector {w // w ≠ c} n := vector.map (corner_retract G h).to_fun CS.cop_init

def cr_pos_to_retract {n: ℕ} (G: refl_graph V) (h: corner_vtx G c) (s: vector V n × V) :  vector {w // w ≠ c} n × {w // w ≠ c} := (vector.map (corner_retract G h).to_fun s.1, (corner_retract G h).to_fun s.2)

def cr_pos_from_retract {n: ℕ} (G: refl_graph V)(h: corner_vtx G c) (s: vector {w // w ≠ c} n × {w // w ≠ c}) : vector V n × V  := (vector.map (λ t, ↑t) s.1, s.2)

def image_strat_fun {n: ℕ} (G: refl_graph V) (h: corner_vtx G c) (CS: cop_strat G n) : vector {w // w ≠ c} n × {w // w ≠ c} → vector {w // w ≠ c} n := λ s, vector.map (corner_retract G h).to_fun (CS.cop_strat (cr_pos_from_retract G h s))

def image_strat {n: ℕ} (G: refl_graph V) (h: corner_vtx G c) (CS: cop_strat G n)
: cop_strat (ind_subgraph_one_vtx c G) n :=
{
  cop_init := image_strat_init G h CS,
  cop_strat := image_strat_fun G h CS,
  cop_nocheat :=
  begin
    intros K cap, rw image_strat_fun, simp, 
    have : capture (cr_pos_from_retract G h K),
      rw capture, cases cap with i cap, use i, rw cr_pos_from_retract, simp, 
      by_contradiction, let nocap := subtype.ne_of_val_ne h, contradiction,
    let G_nocheat := CS.cop_nocheat (cr_pos_from_retract G h K) this,
    rw corner_retract, simp, rw G_nocheat, rw cr_pos_from_retract, simp,
    let map_comp := vec_map_comp coe (retract_fun G h) K.1,
    rw map_comp, exact retract_fn_noncorner_vtx_vect G h K.1,
  end,
  cop_legal :=
  begin
    intros i v P, rw image_strat_fun, simp,
    let move := ((corner_retract G h).to_fun ((CS.cop_strat (cr_pos_from_retract G h (P, v))).nth i)),
    suffices : G.adj (P.nth i) move,
      exact (ind_subgraph_is_induced (λ (x : V), x ≠ c) (P.nth i) move).1 this,
    let G_legal := CS.cop_legal i v (vector.map (λ t, ↑t) P), simp at G_legal,
    let G_copmove := (CS.cop_strat (vector.map coe P, ↑v)).nth i,
    by_cases is_c : G_copmove = c, swap,
    have : ↑((corner_retract G h).to_fun G_copmove) = G_copmove,
      rw corner_retract, simp, rw retract_fun, simp, rw dif_neg is_c, refl,
    change G.adj ↑(P.nth i) G_copmove at G_legal, rw this.symm at G_legal, exact G_legal,
    have : ↑((corner_retract G h).to_fun G_copmove) = cing_vtx h,
      rw corner_retract, simp, rw retract_fun, simp, rw [dif_pos is_c, cing_vtx_subtype], simp,
    change G.adj ↑(P.nth i) G_copmove at G_legal, rw is_c at G_legal, 
    let cing_adj := (cing_vtx_nhds_vtx h) ↑(P.nth i) (rgraph_adj_symm.1 G_legal),
    rw this.symm at cing_adj, exact rgraph_adj_symm.1 cing_adj,
  end,
}

-- goal: to prove that a retract H of a graph G has cop_number H ≤ cop_number G.
-- the standard proof method of this is to "simulate two games played on G and H where the cop strategy is the image_strat and the robber strategy on G is restricted to H."

variables {n: ℕ} (G: refl_graph V) (RS: rob_strat (ind_subgraph_one_vtx c G) n)

def rob_coe_init_fn (h: corner_vtx G c) : vector V n → V := 
λ x, RS.rob_init (vector.map (corner_retract G h).to_fun x)

def rob_coe_init_fn_restr (h: corner_vtx G c) : ∀ x, (rob_coe_init_fn G RS h) x ≠ c :=
begin
  intro x, rw rob_coe_init_fn, simp,
  exact (RS.rob_init (vector.map (corner_retract G h).to_fun x)).2,
end

def rob_coe_strat_fn (h: corner_vtx G c) : vector V n × V → V := λ s, RS.rob_strat (cr_pos_to_retract G h s)

def rob_coe_strat_fn_restr (h: corner_vtx G c) : ∀ s, (rob_coe_strat_fn G RS h) s ≠ c :=
begin
  intro s, rw rob_coe_strat_fn, simp,
  exact (RS.rob_strat (cr_pos_to_retract G h s)).2,
end

-- coercing a robber strat on a graph with corner removed back to the original graph.
def rob_strat_coe {n: ℕ} (G: refl_graph V) (h: corner_vtx G c) (RS: rob_strat (ind_subgraph_one_vtx c G) n) : rob_strat G n :=
{
  rob_init := rob_coe_init_fn G RS h,
  rob_strat := rob_coe_strat_fn G RS h,
  rob_nocheat :=
  begin
    intros K cap, rw rob_coe_strat_fn, simp, 
    have neqc: K.2 ≠ c, sorry,
    suffices : RS.rob_strat (cr_pos_to_retract G h K) = ⟨ K.snd, neqc⟩,
      exact subtype.ext_iff_val.1 this,
    exact RS.rob_nocheat (cr_pos_to_retract G h K), 
  end,
  rob_legal :=
  begin
    intros v P, by_cases v=c, swap,
    rw [cr_pos_to_retract, corner_retract], simp,
    sorry, sorry,
  end
}

lemma cop_num_le_retract [inhabited {w : V// w ≠ c}] (G: refl_graph V) : let H := ind_subgraph_one_vtx c G in
corner_vtx G c → cop_number H ≤ cop_number G :=
begin 
  intros H h,
  unfold cop_number,
  let n := Inf {k : ℕ | k_cop_win G k},
  suffices : k_cop_win H n, exact nat.Inf_le this,
  have n_win: k_cop_win G n, exact nat.Inf_mem (lots_of_cops G),
  rw k_cop_win at n_win, cases n_win with CS n_win,
  rw k_cop_win, use image_strat G h CS,
  rw winning_strat_cop, intro RS, 
  rw winning_strat_cop at n_win, specialize n_win (rob_strat_coe G h RS),
  cases n_win with m cap, use m, cases m, 
  -- base case
  rw [round, rob_strat_coe] at cap, simp at cap,
  rw capture at cap, cases cap with i cap, simp at cap,  
  have no_cap_at_c : CS.cop_init.nth i ≠ c,
    let x := rob_coe_init_fn_restr G RS h CS.cop_init, rw cap.symm at x, exact x,
  rw [round, capture], use i, simp, rw subtype.ext_iff, rw rob_coe_init_fn at cap, simp at cap, conv {congr, skip, rw image_strat,}, simp, rw image_strat_init, rw cap.symm,
  rw image_strat, simp, rw image_strat_init, simp, rw corner_retract, simp, rw retract_fun, simp, rw dif_neg no_cap_at_c, refl, 
  -- inductive case, must case on parity of round
  sorry,
end

-- how to circumvent assuming that subtype is inhabited
lemma cwg_retract_is_cw [inhabited {w : V// w ≠ c}] ( G: refl_graph V) : let H := ind_subgraph_one_vtx c G in
corner_vtx G c →  cop_win_graph G → cop_win_graph H :=
begin
  intros H corner cw, 
  rw cop_win_graph at cw, 
  let leq := cop_num_le_retract G corner, rw cw at leq,
  have : 0 < cop_number (ind_subgraph_one_vtx c G) ,
    exact zero_cops_cant_win (ind_subgraph_one_vtx c G),
  rw cop_win_graph, linarith,
end

def dismantling_order (G: refl_graph V) : list V → Prop
| [] := G ≅ singleton_graph
| (a::L) := (corner_vtx G a) ∧ dismantling_order L

def dismantlable_graph (G: refl_graph V) := ∃ L, dismantling_order G L
